#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <asm/io.h>
#include "address_map_arm.h"
#include <linux/uaccess.h>
#include <linux/fs.h>
#include <linux/cdev.h>


//CONSTANTES
#define DATA_A  0x80
#define DATA_B  0x70
#define START 0xc0

void * LW_virtual; // Lightweight bridge base address
volatile int *DATA_A_PTR, *DATA_B_PTR, *START_PTR; // virtual addresses

struct gpu_amada{
	unsigned char data[4];
} gpu_amada;

static struct drvled_data{
	dev_t devnum;
	struct cdev cdev;
} drvled_data;


int major_number;

	
#define DRIVER_NAME "gpu123"


int device_open(struct inode *inode,struct file *filp){


       // if(down_interruptible(&virtual_device.sem) != 0){

//                printk(KERN_ALERT "nao foi possivel trancar durante a bertura");
  //              return -1;
    //    }
        printk(KERN_INFO "aberto");
        return 0;
}



int ret;

ssize_t device_read(struct file* filp, char* bufStoreData, size_t bufCount, loff_t* curOffset){
        printk(KERN_INFO "lendo");
        ret = copy_to_user(bufStoreData,gpu_amada.data,bufCount);
        return ret;
}


ssize_t device_write(struct file* filp, const char bufSourceData, size_t bufCount, loff_t* curOffset){
        unsigned char buffer1[2];
        unsigned char buffer2[2];
        unsigned char data[4];

        printk(KERN_INFO "escrevendo no dispositivo");
        ret=copy_from_user(&data, bufSourceData, bufCount);
	
	printk(KERN_INFO "passou do copy");
//	for(int i=0; i < 4; i++)
	//	printk("%c\d", gpu_amada.data[i]);

        LW_virtual = ioremap_nocache (LW_BRIDGE_BASE, LW_BRIDGE_SPAN);
        // Set virtual address pointer to I/O port
        DATA_A_PTR = (unsigned int *) (LW_virtual + DATA_A);
        DATA_B_PTR = (unsigned int *) (LW_virtual + DATA_B);   
        START_PTR = (unsigned int *) (LW_virtual + START);   
	
        *buffer1 = (data[0] << 8) | data[1];
        *buffer2 = (data[2] << 8) | data[3];
	printk(KERN_INFO "passsou do buf");
        *START_PTR = 0;
        *DATA_A_PTR = *buffer1;
        *DATA_B_PTR = *buffer2;
        *START_PTR = 1;
	
	printk(KERN_INFO "cabou");

        return ret;
}


/*static ssize_t device_write(struct file *file, const char __user *buf,
			    size_t count, loff_t *ppos)
{
	unsigned char kbuf[4];

	if (copy_from_user(&kbuf, buf,count))
		return -EFAULT;

	//if (kbuf == '1') {
		//drvled_setled(LED_ON);
		//pr_info("LED ON!\n");
	//} else if (kbuf == '0') {
		//drvled_setled(LED_OFF);
		//pr_info("LED OFF!\n");
	//}
	pr_info("escreveu no dispositivo");

	return count;
}

*/

int device_close(struct inode *inode, struct file *filp){
       // up(&virtual_device.sem);
        return 0;

}



static const struct file_operations fops = {

        .owner=THIS_MODULE,
        .open = device_open,
        .release =device_close,
        .write = device_write,
        .read = device_read
};


static int __init init_kernelteste(void) {

    int result;

//     uint16_t buffer1, buffer2;
    result = alloc_chrdev_region(&drvled_data.devnum, 0, 1, DRIVER_NAME);
    if (result) {
	pr_err("%s: Failed to allocate device number!\n", DRIVER_NAME);
	return result;
	}
   // major_number = MAJOR(&drvled_data.devnum);
   // printk(KERN_INFO "major number %d",major_number);
    cdev_init(&drvled_data.cdev, &fops);

    result = cdev_add(&drvled_data.cdev, drvled_data.devnum, 1);
    if (result) {
	pr_err("%s: Char device registration failed!\n", DRIVER_NAME);
	unregister_chrdev_region(drvled_data.devnum, 1);
	return result;
	}

    //drvled_setled(LED_OFF);
    

    pr_info("%s: initialized.\n", DRIVER_NAME);
    // generate a virtual address for the FPGA lightweight bridge
//     LW_virtual = ioremap_nocache (LW_BRIDGE_BASE, LW_BRIDGE_SPAN);
//    // Set virtual address pointer to I/O port
//    DATA_A_PTR = (unsigned int *) (LW_virtual + DATA_A);
//    DATA_B_PTR = (unsigned int *) (LW_virtual + DATA_B);   
//    START_PTR = (unsigned int *) (LW_virtual + START);   

//    *buffer1 = (gpu_amada.data[0] << 8) | gpu_amada.data[1];
//    *buffer2 = (gpu_amada.data[2] << 8) | gpu_data.data[3];

//    *START_PTR = 0;
//    *DATA_A_PTR = *buffer1;
//    *DATA_B_PTR = *buffer2;
//    *START_PTR = 1;


   //*START_PTR = 0;
 // Polygon polygon;
 // polygon.ref_point_X = 10;
 // polygon.ref_point_Y = 10;
 // polygon.size = 0b001;
 // polygon.R = 0;
 // polygon.G = 7;
 // polygon.B = 0;
 // polygon.shape = 0b1;
 // assembleInstructionDP(0b0,polygon);

   return 0;
}

 
static void __exit exit_kernelteste(void) {
   *START_PTR = 0;
    iounmap (LW_virtual);
    cdev_del(&drvled_data.cdev);
    unregister_chrdev_region(drvled_data.devnum, 1);
    pr_info("%s: exiting.\n", DRIVER_NAME);
}

module_init(init_kernelteste);
module_exit(exit_kernelteste);
